name: macOS
on:
  push:
    branches: [ main ]

env:
  APP_NAME: swaggerific
  BUNDLE_ID: io.github.ozkanpakdil.swaggerific
  APP_VERSION: "0.0.4"
  TEAM_ID: TA5X5C9T57

jobs:
  build:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Gluon's GraalVM
        uses: gluonhq/setup-graalvm@master
        with:
          graalvm: '22.1.0.1-Final'
          jdk: 'java17'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Show system info
        run: |
          system_profiler SPSoftwareDataType SPHardwareDataType
          sysctl -a

      - name: Import Developer ID Application certificate
        uses: apple-actions/import-codesign-certs@v2
        with:
          keychain: signing
          keychain-password: ${{ github.run_id }}
          p12-file-base64: ${{ secrets.MACOS_CERTIFICATE_APPLICATION }}
          p12-password: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}

      - name: Import Developer ID Installer certificate
        uses: apple-actions/import-codesign-certs@v2
        with:
          keychain: signing
          keychain-password: ${{ github.run_id }}
          create-keychain: false
          p12-file-base64: ${{ secrets.MACOS_CERTIFICATE_INSTALLER }}
          p12-password: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}

      - name: Make staging directory
        run: mkdir staging

      - name: Gluon License
        uses: gluonhq/gluon-build-license@v1
        with:
          gluon-license: ${{ secrets.GLUON_LICENSE }}

      - name: Create entitlements file
        run: |
          cat > entitlements.plist << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.cs.allow-jit</key>
              <true/>
              <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
              <true/>
              <key>com.apple.security.cs.disable-library-validation</key>
              <true/>
              <key>com.apple.security.cs.allow-dyld-environment-variables</key>
              <true/>
              <key>com.apple.security.network.client</key>
              <true/>
              <key>com.apple.security.network.server</key>
              <true/>
          </dict>
          </plist>
          EOF

      - name: Gluon Build and Package
        id: outputfile
        run: |
          set -e
          ./mvnw -ntp -Pdesktop gluonfx:build gluonfx:package
          chmod +x ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app

          # Generate .icns from applogo.png and patch Info.plist
          ICON_PNG=./src/main/resources/applogo.png
          if [ -f "$ICON_PNG" ]; then
            echo "Generating AppIcon.icns from $ICON_PNG"
            TMP_DIR=$(mktemp -d)
            ICONSET="$TMP_DIR/AppIcon.iconset"
            mkdir -p "$ICONSET"
            for size in 16 32 64 128 256 512; do
              sips -z $size $size     "$ICON_PNG" --out "$ICONSET/icon_${size}x${size}.png" >/dev/null
              dbl=$((size*2))
              sips -z $dbl  $dbl      "$ICON_PNG" --out "$ICONSET/icon_${size}x${size}@2x.png" >/dev/null
            done
            sips -z 1024 1024 "$ICON_PNG" --out "$ICONSET/icon_512x512@2x.png" >/dev/null || true
            iconutil -c icns "$ICONSET" -o ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app/Contents/Resources/AppIcon.icns
            rm -rf "$TMP_DIR" || true
            /usr/libexec/PlistBuddy -c "Set :CFBundleIconFile AppIcon" ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app/Contents/Info.plist 2>/dev/null || \
            /usr/libexec/PlistBuddy -c "Add :CFBundleIconFile string AppIcon" ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app/Contents/Info.plist 2>/dev/null || true
          else
            echo "WARNING: $ICON_PNG not found; keeping default icon"
          fi

      - name: Sign the application
        run: |
          echo "=== Signing all binaries in the .app bundle ==="
          
          # 1. Sign any .dylib files first
          echo "Signing shared libraries (.dylib)..."
          find ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app -name "*.dylib" | while read -r file; do
            echo "Signing dylib: $file"
            chmod +w "$file"
            codesign --force --verify --verbose \
              --sign "Developer ID Application: Ozkan Pakdil (${{ env.TEAM_ID }})" \
              --options runtime \
              --timestamp \
              --entitlements ./entitlements.plist \
              "$file" || true
          done

          # 2. Find and sign all Mach-O binaries and libraries in reverse depth order
          # We use a more comprehensive search to ensure all nested binaries are caught
          # Using find with file to correctly identify Mach-O files regardless of extension
          echo "Scanning for Mach-O binaries..."
          # Identify all potential binaries and libraries using the 'file' command
          find ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app -type f -print0 | while read -r -d '' file; do
            if file "$file" | grep -qE "Mach-O|current ar archive"; then
              echo "$file"
            fi
          done | sort -r | while read -r file; do
            echo "Signing binary: $file"
            # Ensure we have write permissions
            chmod +w "$file"
            # We sign with --options runtime and --timestamp as required by Apple
            codesign --force --verify --verbose \
              --sign "Developer ID Application: Ozkan Pakdil (${{ env.TEAM_ID }})" \
              --options runtime \
              --timestamp \
              --entitlements ./entitlements.plist \
              "$file" || echo "Warning: Failed to sign $file, might not be necessary if it is not a loadable binary."
          done

          # 3. Double-check for any missed executable files (files with +x permission)
          echo "Checking for additional executable files..."
          find ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app -type f -perm +111 -print0 | while read -r -d '' file; do
            # Only sign if it's not already signed or needs resigning
            if ! codesign -v "$file" 2>/dev/null; then
               echo "Signing missed executable: $file"
               chmod +w "$file"
               codesign --force --verify --verbose \
                 --sign "Developer ID Application: Ozkan Pakdil (${{ env.TEAM_ID }})" \
                 --options runtime \
                 --timestamp \
                 --entitlements ./entitlements.plist \
                 "$file" || true
            fi
          done

          # Explicitly sign the main executable again just to be sure
          echo "=== Signing main executable ==="
          MAIN_EXE="./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app/Contents/MacOS/${{ env.APP_NAME }}"
          if [ -f "$MAIN_EXE" ]; then
             chmod +w "$MAIN_EXE"
             # Sign the main executable with entitlements and runtime options
             codesign --force --verify --verbose \
               --sign "Developer ID Application: Ozkan Pakdil (${{ env.TEAM_ID }})" \
               --options runtime \
               --timestamp \
               --entitlements ./entitlements.plist \
               "$MAIN_EXE"
          fi

          echo "=== Signing the .app bundle ==="
          # Use --deep as a final verification/reinforcement, though individual signing is better
          codesign --force --verify --verbose --deep \
            --sign "Developer ID Application: Ozkan Pakdil (${{ env.TEAM_ID }})" \
            --options runtime \
            --timestamp \
            --entitlements ./entitlements.plist \
            ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app
          
          echo "=== Verifying signature ==="
          codesign --verify --verbose=4 --deep ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app
          # Check with spctl to see what Gatekeeper thinks
          spctl --assess --verbose=4 --type execute ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app || true

      - name: Create and sign installer package
        run: |
          echo "=== Creating signed .pkg installer ==="
          # Use --component to correctly package the .app bundle, which is more reliable than --root for single apps
          # Ensure the .app bundle is signed before packaging
          pkgbuild --component ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app \
            --identifier ${{ env.BUNDLE_ID }} \
            --version ${{ env.APP_VERSION }} \
            --install-location /Applications \
            --sign "Developer ID Installer: Ozkan Pakdil (${{ env.TEAM_ID }})" \
            Swaggerific.pkg
          
          # Create the final distribution package
          productbuild --package Swaggerific.pkg \
            --sign "Developer ID Installer: Ozkan Pakdil (${{ env.TEAM_ID }})" \
            SwaggerificInstaller.pkg
          
          echo "=== Verifying pkg signature ==="
          pkgutil --check-signature SwaggerificInstaller.pkg

      - name: Setup notarization credentials
        run: |
          mkdir -p ~/private_keys
          echo "${{ secrets.APPLE_API_KEY }}" | base64 --decode > ~/private_keys/AuthKey_${{ secrets.APPLE_API_KEY_ID }}.p8

      - name: Notarize the application
        run: |
          echo "=== Creating zip for notarization ==="
          ditto -c -k --keepParent ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app ${{ env.APP_NAME }}.zip
          
          echo "=== Submitting app for notarization ==="
          # Submit and capture the output to get submission ID
          # Use --wait to block until finished, but we'll handle the timeout/error
          xcrun notarytool submit ${{ env.APP_NAME }}.zip \
            --key ~/private_keys/AuthKey_${{ secrets.APPLE_API_KEY_ID }}.p8 \
            --key-id ${{ secrets.APPLE_API_KEY_ID }} \
            --issuer ${{ secrets.APPLE_API_ISSUER_ID }} \
            --wait > notarization_output.txt 2>&1 || true
          
          cat notarization_output.txt
          
          # Extract submission ID
          SUBMISSION_ID=$(grep -o 'id: [a-f0-9-]*' notarization_output.txt | head -1 | cut -d' ' -f2)
          echo "Submission ID: $SUBMISSION_ID"
          
          # Check if notarization was successful
          if grep -q "status: Accepted" notarization_output.txt; then
            echo "=== Notarization successful! ==="
          else
            echo "=== Notarization failed or timed out, fetching log ==="
            if [ -n "$SUBMISSION_ID" ]; then
              xcrun notarytool log "$SUBMISSION_ID" \
                --key ~/private_keys/AuthKey_${{ secrets.APPLE_API_KEY_ID }}.p8 \
                --key-id ${{ secrets.APPLE_API_KEY_ID }} \
                --issuer ${{ secrets.APPLE_API_ISSUER_ID }} \
                notarization_app_log.json || true
              cat notarization_app_log.json || true
            fi
            exit 1
          fi
          
          echo "=== Stapling notarization ticket to app ==="
          xcrun stapler staple ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app

      - name: Notarize the installer package
        run: |
          echo "=== Submitting pkg for notarization ==="
          # Submit and capture the output to get submission ID
          xcrun notarytool submit SwaggerificInstaller.pkg \
            --key ~/private_keys/AuthKey_${{ secrets.APPLE_API_KEY_ID }}.p8 \
            --key-id ${{ secrets.APPLE_API_KEY_ID }} \
            --issuer ${{ secrets.APPLE_API_ISSUER_ID }} \
            --wait > notarization_pkg_output.txt 2>&1 || true
          
          cat notarization_pkg_output.txt
          
          # Extract submission ID
          SUBMISSION_ID=$(grep -o 'id: [a-f0-9-]*' notarization_pkg_output.txt | head -1 | cut -d' ' -f2)
          echo "Submission ID: $SUBMISSION_ID"
          
          # Check if notarization was successful
          if grep -q "status: Accepted" notarization_pkg_output.txt; then
            echo "=== Notarization successful! ==="
          else
            echo "=== Notarization failed or timed out, fetching log ==="
            if [ -n "$SUBMISSION_ID" ]; then
              xcrun notarytool log "$SUBMISSION_ID" \
                --key ~/private_keys/AuthKey_${{ secrets.APPLE_API_KEY_ID }}.p8 \
                --key-id ${{ secrets.APPLE_API_KEY_ID }} \
                --issuer ${{ secrets.APPLE_API_ISSUER_ID }} \
                notarization_pkg_log.json || true
              cat notarization_pkg_log.json || true
            fi
            exit 1
          fi
          
          echo "=== Stapling notarization ticket to pkg ==="
          xcrun stapler staple SwaggerificInstaller.pkg

      - name: Prepare staging artifacts
        run: |
          cp -r ./target/gluonfx/x86_64-darwin/${{ env.APP_NAME }}.app staging/
          tar -czvf staging/swaggerific_x86_64-darwin.tar.gz -C target/gluonfx/x86_64-darwin ${{ env.APP_NAME }}.app
          cp -r SwaggerificInstaller.pkg staging/
          
          

      - name: Upload
        uses: actions/upload-artifact@v4
        with:
          name: Package
          path: staging

      - name: Create GitHub Release
        uses: "marvinpinto/action-automatic-releases@latest"
        with:
          repo_token: "${{ secrets.GITHUB_TOKEN }}"
          automatic_release_tag: "latest_macos"
          prerelease: true
          title: "MacOS Development Build (Signed & Notarized)"
          files: |
            staging/*
        id: "automatic_releases"

      - name: Update Homebrew Cask
        run: |
          # Calculate SHA256 of the tar.gz file
          SHA256=$(shasum -a 256 staging/swaggerific_x86_64-darwin.tar.gz | awk '{print $1}')
          echo "SHA256: $SHA256"
          
          # Update the cask file with the new SHA256
          cat > Casks/swaggerific.rb << EOF
          cask "swaggerific" do
            version "${{ env.APP_VERSION }}"
            sha256 "$SHA256"

            url "https://github.com/ozkanpakdil/swaggerific/releases/download/latest_macos/swaggerific_x86_64-darwin.tar.gz",
                verified: "github.com/ozkanpakdil/swaggerific"
            name "Swaggerific"
            desc "Simple GUI app for working with Swagger/OpenAPI"
            homepage "https://github.com/ozkanpakdil/swaggerific"

            app "swaggerific.app"

            caveats <<~EOS
              This app is signed and notarized with a Developer ID certificate.
              It should open without any Gatekeeper warnings.
            EOS
          end
          EOF

      - name: Commit and push Homebrew Cask update
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add Casks/swaggerific.rb
          git diff --staged --quiet || git commit -m "Update Homebrew cask SHA256 for version ${{ env.APP_VERSION }}"
          git push
